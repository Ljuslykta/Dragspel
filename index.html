<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notvisare med Tonarter</title>
    <style>
        body { font-family: sans-serif; text-align: center; background: #f0f0f0; margin: 0; padding: 20px; }
        h1 { color: #333; margin-bottom: 10px; }
        
        /* Layout */
        .controls { margin-bottom: 20px; background: #fff; padding: 15px; display: inline-block; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        select { padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc; margin-left: 10px; }
        
        #canvas-container { position: relative; display: inline-block; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        canvas { display: block; }
        
        #note-info { margin-top: 10px; min-height: 60px; }
        #note-name { font-size: 40px; font-weight: bold; color: #d32f2f; display: inline-block; margin-right: 15px; }
        #frequency { color: #666; font-size: 14px; display: inline-block; vertical-align: middle; }
        
        button#startBtn { background: #007bff; color: white; border: none; padding: 15px 30px; font-size: 18px; border-radius: 5px; cursor: pointer; margin: 20px 0; }
        button#startBtn:hover { background: #0056b3; }
        
        .hidden { display: none; }
    </style>
</head>
<body>

    <h1>üéµ Notvisare Pro</h1>

    <div class="controls">
        <label for="keySelect">V√§lj Tonart:</label>
        <select id="keySelect">
            <option value="C">C-dur (Inga f√∂rtecken)</option>
            <option value="G">G-dur (1 # - F#)</option>
            <option value="D">D-dur (2 # - F#, C#)</option>
            <option value="A">A-dur (3 # - F#, C#, G#)</option>
            <option value="E">E-dur (4 # - F#, C#, G#, D#)</option>
            <option value="F">F-dur (1 ‚ô≠ - Bb)</option>
            <option value="Bb">Bb-dur (2 ‚ô≠ - Bb, Eb)</option>
            <option value="Eb">Eb-dur (3 ‚ô≠ - Bb, Eb, Ab)</option>
        </select>
    </div>
    
    <br>
    <button id="startBtn">Starta Mikrofonen</button>

    <div id="content" class="hidden">
        <div id="canvas-container">
            <canvas id="staffCanvas" width="500" height="300"></canvas>
        </div>
        <div id="note-info">
            <span id="note-name">--</span>
            <span id="frequency">0 Hz</span>
        </div>
    </div>

    <script>
        // --- INST√ÑLLNINGAR & VARIABLER ---
        const canvas = document.getElementById('staffCanvas');
        const ctx = canvas.getContext('2d');
        const noteDisplay = document.getElementById('note-name');
        const freqDisplay = document.getElementById('frequency');
        const keySelect = document.getElementById('keySelect');
        
        let audioContext, analyser, microphone, dataArray;
        let currentKey = "C";

        // --- MUSIKTEORI DATA ---
        
        // Vilka noter ing√•r i vilken skala? (Anv√§nds f√∂r att avg√∂ra om #/b/√•terst√§llningstecken ska visas vid noten)
        const keyDefinitions = {
            "C":  { type: "sharp", count: 0, notes: ["C", "D", "E", "F", "G", "A", "B"] },
            "G":  { type: "sharp", count: 1, notes: ["G", "A", "B", "C", "D", "E", "F#"] },
            "D":  { type: "sharp", count: 2, notes: ["D", "E", "F#", "G", "A", "B", "C#"] },
            "A":  { type: "sharp", count: 3, notes: ["A", "B", "C#", "D", "E", "F#", "G#"] },
            "E":  { type: "sharp", count: 4, notes: ["E", "F#", "G#", "A", "B", "C#", "D#"] },
            "F":  { type: "flat",  count: 1, notes: ["F", "G", "A", "Bb", "C", "D", "E"] },
            "Bb": { type: "flat",  count: 2, notes: ["Bb", "C", "D", "Eb", "F", "G", "A"] },
            "Eb": { type: "flat",  count: 3, notes: ["Eb", "F", "G", "Ab", "Bb", "C", "D"] }
        };

        // Koordinater f√∂r var # och b ska ritas i tonarten (relativt mittlinjen B4)
        // 0 = B4. Positivt = upp√•t, Negativt = ned√•t. Varje steg √§r en halv position (linje/mellanrum).
        const sharpPositions = [4, 1, 5, 2]; // F (topplinje), C, G, D
        const flatPositions = [0, 3, -1];    // B (mittlinje), E, A

        // Notnamn arrayer
        const sharpNotes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const flatNotes  = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        
        // Ordning p√• "vita tangenter" f√∂r h√∂jdber√§kning (C, D, E, F, G, A, B)
        const whiteKeySteps = [0, 2, 4, 5, 7, 9, 11];

        // --- H√ÑNDELSER ---
        keySelect.addEventListener('change', (e) => {
            currentKey = e.target.value;
        });

        document.getElementById('startBtn').addEventListener('click', async () => {
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('content').classList.remove('hidden');
            await startAudio();
            drawLoop();
        });

        // --- LJUDHANTERING ---
        async function startAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                dataArray = new Float32Array(analyser.fftSize);
            } catch (err) {
                alert("Kunde inte starta mikrofonen.");
            }
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.015) return -1; // Brusfilter (h√∂j om det flimrar)

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE - i; j++) c[i] += buf[j] * buf[j + i];

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            
            return sampleRate / maxpos;
        }

        function getNoteInfo(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            const midiNote = Math.round(noteNum) + 69;
            
            // Best√§m namn baserat p√• om tonarten √§r # eller b
            const keyData = keyDefinitions[currentKey];
            const useFlats = keyData.type === "flat";
            const noteList = useFlats ? flatNotes : sharpNotes;
            
            const rawNoteName = noteList[midiNote % 12]; // T.ex. "F#" eller "Gb"
            const octave = Math.floor(midiNote / 12) - 1;

            return { midiNote, rawNoteName, octave };
        }

        // --- RITNING ---
        function drawStaff(settings) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.fillStyle = "#000";

            const { startY, lineSpacing } = settings;

            // Rita 5 linjer
            for (let i = 0; i < 5; i++) {
                let y = startY + (i * lineSpacing);
                ctx.beginPath();
                ctx.moveTo(20, y);
                ctx.lineTo(480, y);
                ctx.stroke();
            }

            // G-klav
            ctx.font = "60px serif";
            ctx.fillText("ùÑû", 20, startY + 3 * lineSpacing);

            // Rita Tonart (Fasta f√∂rtecken)
            drawKeySignature(settings);
        }

        function drawKeySignature(settings) {
            const keyData = keyDefinitions[currentKey];
            const { startY, lineSpacing } = settings;
            const middleLineY = startY + 2 * lineSpacing; // B4
            const halfStep = lineSpacing / 2;
            
            ctx.font = "24px serif"; // Font f√∂r # och b
            
            let startX = 60; // Startposition efter G-klav

            if (keyData.type === "sharp") {
                for(let i=0; i<keyData.count; i++) {
                    // H√§mta position reltivt B-linjen
                    let pos = sharpPositions[i]; 
                    // Konvertera till Y (invertera pos eftersom canvas Y √∂kar ned√•t)
                    let y = middleLineY - (pos * halfStep) + 8; // +8 f√∂r att centrera texten
                    ctx.fillText("‚ôØ", startX + (i * 15), y);
                }
            } else if (keyData.type === "flat") {
                for(let i=0; i<keyData.count; i++) {
                    let pos = flatPositions[i];
                    let y = middleLineY - (pos * halfStep) + 8;
                    ctx.fillText("‚ô≠", startX + (i * 15), y);
                }
            }
        }

        function drawNote(noteInfo, settings) {
            // H√§r √§r "hj√§rnan" f√∂r att visa r√§tt tecken beroende p√• tonart
            const keyData = keyDefinitions[currentKey];
            const scaleNotes = keyData.notes; // T.ex. ["G", "A", "B", "C", "D", "E", "F#"]
            
            // 1. Vilken "stamton" (bokstav) √§r det?
            // Vi m√•ste analysera midi-noten.
            // Exempel: G-dur (har F#). Vi spelar F# (Midi 66).
            // RawNoteName = "F#". 
            // Stamtonen b√∂r vara "F".
            
            let baseNoteChar = noteInfo.rawNoteName.charAt(0); // "F" ur "F#"
            let accidental = noteInfo.rawNoteName.length > 1 ? noteInfo.rawNoteName.charAt(1) : ""; // "#" eller "b" eller ""

            // Specialfall: Om vi √§r i en b-tonart (F-dur) och pitch detectorn ger A# (Midi 70), 
            // men F-dur skalan har Bb (ocks√• Midi 70).
            // D√• √§r rawNoteName redan konverterat till "Bb" av getNoteInfo pga flaggan 'useFlats'.
            
            // 2. Ber√§kna visuell h√∂jd (position p√• notsystemet)
            // Vi anv√§nder stamtonen (C, D, E...) f√∂r att hitta raden.
            // C4 (Midi 60) √§r basen.
            const baseNotes = ["C", "D", "E", "F", "G", "A", "B"];
            const baseIndex = baseNotes.indexOf(baseNoteChar);
            
            // R√§kna ut hur m√•nga "steg" fr√•n C4 vi √§r
            // (Oktavskillnad * 7) + indexskillnad
            const octaveDiff = noteInfo.octave - 4;
            const visualSteps = (octaveDiff * 7) + baseIndex;
            
            // B4 (Mittenlinjen) √§r steg 6 (C,D,E,F,G,A,B). 
            // Vi vill r√§kna position relativt B4 f√∂r att rita p√• canvas.
            const stepsFromB4 = visualSteps - 6;
            
            const { startY, lineSpacing } = settings;
            const middleLineY = startY + 2 * lineSpacing;
            const halfStep = lineSpacing / 2;
            
            // Y-koordinat (inverterad, h√∂gre steg = l√§gre Y)
            const noteY = middleLineY - (stepsFromB4 * halfStep);

            // 3. Best√§m vilket tecken som ska ritas bredvid noten
            // Vi j√§mf√∂r den spelade noten (noteInfo.rawNoteName) med vad som "f√∂rv√§ntas" i tonarten f√∂r den stamtonen.
            
            let symbolToDraw = "";
            
            // Hitta vad skalan f√∂rv√§ntar sig f√∂r denna bokstav (t.ex. f√∂r 'F' i G-dur f√∂rv√§ntas 'F#')
            const expectedNote = scaleNotes.find(n => n.startsWith(baseNoteChar));
            
            // J√§mf√∂r spelad not med f√∂rv√§ntad not
            if (noteInfo.rawNoteName === expectedNote) {
                // Noten ing√•r i tonarten (t.ex. F# i G-dur). Inget tecken beh√∂vs!
                symbolToDraw = ""; 
            } else {
                // Noten avviker!
                if (accidental === "") {
                    // Vi spelar en naturell ton (t.ex. F), men skalan har F#.
                    // Vi m√•ste visa √•terst√§llningstecken.
                    symbolToDraw = "‚ôÆ";
                } else if (accidental === "#") {
                    symbolToDraw = "‚ôØ";
                } else if (accidental === "b") {
                    symbolToDraw = "‚ô≠";
                }
            }

            // Rita noten
            ctx.beginPath();
            ctx.arc(250, noteY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = "#000";
            ctx.fill();
            
            // Rita hj√§lplinjer om det beh√∂vs (ovanf√∂r/under notsystemet)
            // Topplinjen √§r F5 (steg 10 fr√•n C4). Bottenlinjen √§r E4 (steg 2).
            // B4 √§r steg 6.
            // Om visualSteps > 10 (G5 och upp√•t) eller < 2 (D4, C4 och ned√•t)
            
            // F√∂renklad hj√§lplinje-logik f√∂r C4 (Middle C)
            if (visualSteps === 0) { // C4
                ctx.beginPath();
                ctx.moveTo(230, noteY);
                ctx.lineTo(270, noteY);
                ctx.stroke();
            }

            // Rita tillf√§lligt f√∂rtecken (symbolToDraw)
            if (symbolToDraw) {
                ctx.font = "24px serif";
                ctx.fillText(symbolToDraw, 220, noteY + 8);
            }
        }

        function drawLoop() {
            requestAnimationFrame(drawLoop);
            
            // Rita bakgrunden
            const settings = { startY: 100, lineSpacing: 20 };
            drawStaff(settings);

            analyser.getFloatTimeDomainData(dataArray);
            let frequency = autoCorrelate(dataArray, audioContext.sampleRate);
            
            if (frequency > 60 && frequency < 3000) {
                const info = getNoteInfo(frequency);
                
                // Uppdatera texten
                noteDisplay.innerText = info.rawNoteName;
                freqDisplay.innerText = Math.round(frequency) + " Hz";

                // Rita noten p√• pappret
                drawNote(info, settings);
            }
        }
    </script>
</body>
</html>
